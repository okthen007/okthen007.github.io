<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"shuo-shuo.site","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Sure&#39;s BLOG">
<meta property="og:url" content="http://shuo-shuo.site/index.html">
<meta property="og:site_name" content="Sure&#39;s BLOG">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Sure Zheng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://shuo-shuo.site/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Sure's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sure's BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/About/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/Categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">20</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/Schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://shuo-shuo.site/2024/06/16/%E6%B5%85%E8%B0%88%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E6%8E%A8%E8%8D%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sure Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sure's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/16/%E6%B5%85%E8%B0%88%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E6%8E%A8%E8%8D%90/" class="post-title-link" itemprop="url">浅谈大语言模型推荐</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-06-16 21:33:16 / Modified: 22:03:27" itemprop="dateCreated datePublished" datetime="2024-06-16T21:33:16+08:00">2024-06-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>956</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>DLRM to GR works？<br>推荐系统是 近十年来兴起的话题，大模型近两年快速兴趣，如何将大模型应用于推荐系统领域，通过LLM生成式推荐的思路。通过 Meta 工业界首个万亿级别参数的生成式推荐模型，分析下 “生成式推荐” 是否可行。<br><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2402.17152">https://arxiv.org/pdf/2402.17152</a></p>
<h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><p>输入是用户交互过的历史item序列，只考虑稀疏特征，放弃连续特征；新设计encoder模型HSTU，相比DLRM模型，模型复杂度提升285倍；训练和推理都采用内存、计算优化的方案；</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在召回、排序场景，线上指标召回+6.4%，排序+12.4%；</p>
<h2 id="性能基线"><a href="#性能基线" class="headerlink" title="性能基线"></a>性能基线</h2><p>8192的序列长度上HSTU比FlashAttention2加速5.3x-15.2x，推理通过成本分摊M-FALCON方式在DLRM同等资源配置下吞吐提升1.5倍。</p>
<p><img src="../Pics/GR.png" alt="模型架构图"></p>
<h2 id="区别改造"><a href="#区别改造" class="headerlink" title="区别改造"></a>区别改造</h2><h3 id="输入数据构造"><a href="#输入数据构造" class="headerlink" title="输入数据构造"></a>输入数据构造</h3><p>将用户行为定义为“新模态”，无损信息直接输入类LLM模型。<br>Categorical（’sparse’）特征：进行序列化<br>选取最长的时间序列（通常是将用户交互的 item 合并）作为主要的时间序列。<br>其余的特征是随着时间缓慢变化的时间序列，例如用户关注的创作者等。通过保留每个连续片段最早的条目来压缩这些时间序列，并将结果合并到主序列中。<br>Numerical（’dense’）特征：直接丢弃<br>这类特征变化更为频繁，从计算和存储的角度将这些特征完全序列化是不可行的。<br>这些数值特征是由类别特征聚合而来，而这些类别特征我们已经编码入了模型。<br>通过这种设计，可以有效降低序列的长度。</p>
<h3 id="召回任务"><a href="#召回任务" class="headerlink" title="召回任务"></a>召回任务</h3><p>训练：基于历史行为序列，随机mask掉一些item，预测这些item，计算loss；<br>推理：基于历史行为序列，需要一次预测一批item，基于模型输出embedding，映射到全量item库（会有采样策略）；</p>
<h3 id="排序任务"><a href="#排序任务" class="headerlink" title="排序任务"></a>排序任务</h3><p>训练：基于历史行为序列，随机mask掉一些item的action，预测这些item的action，计算loss；<br>推理：基于历史行为序列，将待排序的item append到用户历史行为序列里，预测action位置的embeding，再外接NN模型适配多任务，输出具体结果；</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>scaling law在参数高达1.5万亿时还能scaling，而作为对比的DLRMs在参数达到2000亿的时候性能就开始下降；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://shuo-shuo.site/2024/04/06/%E6%A0%B7%E6%9C%AC%E5%B7%A5%E7%A8%8B%E7%AE%80%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sure Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sure's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/06/%E6%A0%B7%E6%9C%AC%E5%B7%A5%E7%A8%8B%E7%AE%80%E8%BF%B0/" class="post-title-link" itemprop="url">样本工程简述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-06 21:48:09" itemprop="dateCreated datePublished" datetime="2024-04-06T21:48:09+08:00">2024-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-06-16 22:03:29" itemprop="dateModified" datetime="2024-06-16T22:03:29+08:00">2024-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Categories/%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="训练样本"><a href="#训练样本" class="headerlink" title="训练样本"></a>训练样本</h2><p>深度模型通常在 TensorFlow 中训练，样本处理通常 Pyspark、Spark、Flink 等技术处理数据，但是训练样本链路也可以通过 TensorFlow 中的 OP 算子直接进行数据处理，从而保证离在线一致性。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>特征包括 “物品特征”、“用户特征（用户历史行为特征）”、“场景特征”</p>
<h2 id="生成样本时避免引入未来信息"><a href="#生成样本时避免引入未来信息" class="headerlink" title="生成样本时避免引入未来信息"></a>生成样本时避免引入未来信息</h2><p>如果我们在 t 时刻进行模型预测，那么 t+1 时刻的信息就是未来信息。这个问题在模型线上服务的时候是不存在的，因为未来的事情还未发生，我们不可能知道。但在离线训练的时候，我们就容易犯这样的错误。比如说，我们利用 t 时刻的样本进行训练，但是使用了全量的样本生成特征，这些特征就包含了 t+1 时刻的未来信息，这就是一个典型的引入未来信息的错误例子。</p>
<p>在做 rating 平均这个操作的时候，我们不要对这个 userId 下面的所有评分取平均值，而是要创建一个滑动窗口，先把这个用户下面的评分按照时间排序，再让这个滑动窗口一一滑动，滑动窗口的位置始终在当前 rating 前一个 rating 的位置。这样，我们再对滑动窗口内的分数做平均，就不会引入未来信息了</p>
<h2 id="特征数据存入线上供模型服务用"><a href="#特征数据存入线上供模型服务用" class="headerlink" title="特征数据存入线上供模型服务用"></a>特征数据存入线上供模型服务用</h2><figure class="highlight bash"><figcaption><span>特征数据存储到 redis</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val userKey = userFeaturePrefix + sample.getAs[String](<span class="string">&quot;userId&quot;</span>)</span><br><span class="line">val valueMap = mutable.Map[String, String]()</span><br><span class="line">valueMap(<span class="string">&quot;userRatedMovie1&quot;</span>) = sample.getAs[String](<span class="string">&quot;userRatedMovie1&quot;</span>)</span><br><span class="line">valueMap(<span class="string">&quot;userRatedMovie2&quot;</span>) = sample.getAs[String](<span class="string">&quot;userRatedMovie2&quot;</span>)</span><br><span class="line">...</span><br><span class="line">valueMap(<span class="string">&quot;userAvgRating&quot;</span>) = sample.getAs[String](<span class="string">&quot;userAvgRating&quot;</span>)</span><br><span class="line">valueMap(<span class="string">&quot;userRatingStddev&quot;</span>) = sample.getAs[String](<span class="string">&quot;userRatingStddev&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redisClient.hset(userKey, JavaConversions.mapAsJavaMap(valueMap))</span><br></pre></td></tr></table></figure>
<p>在样本处理过程中，我们选用评分和基于评分生成的好评差评标识作为样本标签，并基于 ratings 表的每条数据，通过联合物品和用户数据生成训练样本。在训练样本的生成中，要特别注意“未来信息”的问题，利用 Spark 中的 window 函数滑动生成历史行为相关特征。最后我们利用 Redis 的 hset 操作把线上推断用的特征存储 Redis。</p>
<h2 id="Youtube-举例"><a href="#Youtube-举例" class="headerlink" title="Youtube 举例"></a>Youtube 举例</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://shuo-shuo.site/2024/03/31/%E6%B5%85%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86-dataservice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sure Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sure's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/31/%E6%B5%85%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86-dataservice/" class="post-title-link" itemprop="url">浅谈分布式数据预处理-dataservice</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-03-31 00:12:01 / Modified: 00:21:01" itemprop="dateCreated datePublished" datetime="2024-03-31T00:12:01+08:00">2024-03-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Categories/%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Categories/%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%A0%B7%E6%9C%AC%E5%8A%A0%E9%80%9F/" itemprop="url" rel="index"><span itemprop="name">样本加速</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Dataservice-简述"><a href="#Dataservice-简述" class="headerlink" title="Dataservice 简述"></a>Dataservice 简述</h1><p>Dataservice 模块是 Tensorflow 2.3 版本中的一个重要部分，核心功能是实现分布式预处理 pipeline，核心解决问题还是数据处理 IO 问题，和大数据处理中的 Mapreduce 有点相像，核心概念是 JobTracker, TaskTrackier 和 TaskRunner；</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>在TF Dataservice中也有着相对应的核心概念，涉及到进程/线程实体的有Dispatcher，Worker，TaskRunner；涉及到任务概念的有Job、Task以及Dataset。</p>
<ul>
<li>Dataset<br>Tensorflow中采用了类似于Spark中RDD的思想：即对整个Dataset实现处理变换；Dataset只是定义着基础的操作，而关于并发处理等制实际上是在Dataset上封装的一层Iterator里进行实现；</li>
<li>Job<br>Job是Dataservice中对于数据处理pipeline这个层面的概念抽象。相当于一系列数据处理操作的集合就是一个Job</li>
<li>Task<br>一个Job是会对应着多个Task的。比如我现在使用8个进程去并行执行数据读取，那么就会有8个Task</li>
</ul>
<h2 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h2><p>Dataservice中采用几乎和Spark运行一一对应的概念，其中Dispatcher对应JobTracker，Worker对应TaskTracker，TaskRunner对应TaskRunner。只不过在TF中，worker接收到一个Task之后不需要重新起一个JVM来执行代码，而是直接进行函数调用即可。整体而言TFDataservice中的分布式数据处理的架构如下图所示。这个图看起来有点乱，但是基本上就描述清了TFDataservice中的设计。Dispatcher和Worker都是两个RPC Server。Dataset和Dispatcher，Dispatcher和Worker以及Dataset和Worker之间都是采用RPC调用进行通信。</p>
<h2 id="数据读取流程"><a href="#数据读取流程" class="headerlink" title="数据读取流程"></a>数据读取流程</h2><p>当Dataset被迭代的时候，Dataset会直接和对应的worker进行通信，调用Worker的GetElement的RPC方法直接获取数据；<br>实际上当我们创建了一个DataServiceDataset的时候，该Dataset也会定期和Dispatcher进行Heartbeat通信。在非RoundRobin的读取方式下，Dataset与Dispatcher通信的核心目的是知道自己的Job被创建了哪些Task。当Dispatcher接收到来自JobClient的Heartbeat时，会返回给Dataset所有其Job相关的Task。</p>
<h2 id="Pytorch-场景很难做到的原因待探索"><a href="#Pytorch-场景很难做到的原因待探索" class="headerlink" title="Pytorch 场景很难做到的原因待探索"></a>Pytorch 场景很难做到的原因待探索</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://shuo-shuo.site/2024/03/17/%E6%B5%85%E8%B0%88%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sure Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sure's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/17/%E6%B5%85%E8%B0%88%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/" class="post-title-link" itemprop="url">浅谈对象存储</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-03-17 22:51:28 / Modified: 23:48:21" itemprop="dateCreated datePublished" datetime="2024-03-17T22:51:28+08:00">2024-03-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Categories/%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>302</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="对象存储是什么"><a href="#对象存储是什么" class="headerlink" title="对象存储是什么"></a>对象存储是什么</h2><p>对象存储 OSS（Object-based Storage）通常可以用来（像本地磁盘一样）存储模型、存储数据。</p>
<h2 id="对象存储展现形式"><a href="#对象存储展现形式" class="headerlink" title="对象存储展现形式"></a>对象存储展现形式</h2><p>对象存储通常以文件夹/目录的形式展现，以 文件夹、bucket（对象呈现出来的），包括 Key、Data、MetaData 展示文件所处位置，通常采用树形目录。</p>
<h2 id="对象存储的优势"><a href="#对象存储的优势" class="headerlink" title="对象存储的优势"></a>对象存储的优势</h2><ul>
<li>查询速度快</li>
<li>扩容简单</li>
<li>安全性高</li>
<li>使用方便（根据 key value 匹配）</li>
<li>容灾机制完善</li>
</ul>
<h2 id="存储内容"><a href="#存储内容" class="headerlink" title="存储内容"></a>存储内容</h2><ul>
<li>图片、音频存储</li>
<li>静态动态资源隔离</li>
</ul>
<h2 id="NAS-存储架构"><a href="#NAS-存储架构" class="headerlink" title="NAS 存储架构"></a>NAS 存储架构</h2><ul>
<li>横向扩展功能（增加硬盘）</li>
<li>高性能</li>
<li>可访问性和容错性</li>
</ul>
<h2 id="构建时可能需要内容分发解决方案："><a href="#构建时可能需要内容分发解决方案：" class="headerlink" title="构建时可能需要内容分发解决方案："></a>构建时可能需要内容分发解决方案：</h2><p>电商平台<br>社交媒体<br>视频点播<br>App Store<br>oss 等对象存储机制，也可以作为 AI数据集加速的重要部分</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://shuo-shuo.site/2024/03/10/%E5%AE%9E%E6%97%B6%E7%89%B9%E5%BE%81%E5%8A%A0%E5%B7%A5%E9%93%BE%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sure Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sure's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/10/%E5%AE%9E%E6%97%B6%E7%89%B9%E5%BE%81%E5%8A%A0%E5%B7%A5%E9%93%BE%E8%B7%AF/" class="post-title-link" itemprop="url">实时特征加工链路</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-03-10 22:10:54" itemprop="dateCreated datePublished" datetime="2024-03-10T22:10:54+08:00">2024-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-03-18 23:03:50" itemprop="dateModified" datetime="2024-03-18T23:03:50+08:00">2024-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="特征工程和-Embedding"><a href="#特征工程和-Embedding" class="headerlink" title="特征工程和 Embedding"></a>特征工程和 Embedding</h1><p>Embedding 特征向量(Embedding 就是用一个数值向量“表示”一个对象（Object）的方法)，用向量表示一个物体，主要目的是对稀疏特征进行降维，主要可作为推荐系统的召回层或召回策略之一<br>优势在于，通过低维向量表达，能够体现距离的远近；本质是无监督学习方法</p>
<p>如何进行 Embedding？<br>流行的词嵌入方法，word2vec，Node2vec，skipgram等，Pytorch 中使用 nn.Embedding() TF是end2end训练embedding层，并不是w2v实现。</p>
<h3 id="Embedding方法：word2vec"><a href="#Embedding方法：word2vec" class="headerlink" title="Embedding方法：word2vec"></a>Embedding方法：word2vec</h3><p>Word2vec 模型分为两种形式，CBOW 模型 和 Skip-gram 模型。</p>
<ul>
<li><p>Word2Vec 样本生产<br>我们从语料库中抽取一个句子，选取一个长度为 2c+1（目标词前后各选 c 个词）的滑动窗口，将滑动窗口由左至右滑动，每移动一次，窗口中的词组就形成了一个训练样本。根据 Skip-gram 模型的理念，中心词决定了它的相邻词，我们就可以根据这个训练样本定义出 Word2vec 模型的输入和输出，输入是样本的中心词，输出是所有的相邻词。</p>
</li>
<li><p>Word2Vec 模型结构<br>三层神经网络。</p>
</li>
<li><p>它的输入层和输出层的维度都是 V，这个 V 其实就是语料库词典的大小</p>
</li>
<li><p>Word2vec 模型解决的是一个多分类问题</p>
</li>
<li><p>隐层的维度是 N，N 的选择就需要一定的调参能力了，我们需要对模型的效果和模型的复杂度进行权衡，来决定最后 N 的取值，并且最终每个词的 Embedding 向量维度也由 N 来决定。</p>
</li>
<li><p>隐层神经元是没有激活函数的，或者说采用了输入即输出的恒等函数作为激活函数，而输出层神经元采用了 softmax 作为激活函数。<br><img src="../Pics/word2vec-model.png" alt="word2vec"><br>这个由输入词 WI 预测输出词 WO 的条件概率，其实就是 Word2vec 神经网络要表达的东西。我们通过极大似然的方法去最大化这个条件概率，就能够让相似的词的内积距离更接近，这就是我们希望 Word2vec 神经网络学到的。<br>进阶学法：为了节约训练时间，Word2vec 经常会采用负采样（Negative Sampling）或者分层 softmax（Hierarchical Softmax）的训练方法。</p>
</li>
<li><p>词向量从 Word2vec 模型中提取出来<br>我们往往会把输入向量矩阵转换成词向量查找表（Lookup table，如图 7 所示）。例如，输入向量是 10000 个词组成的 One-hot 向量，隐层维度是 300 维，那么输入层到隐层的权重矩阵为 10000x300 维。在转换为词向量 Lookup table 后，每行的权重即成了对应词的 Embedding 向量。如果我们把这个查找表存储到线上的数据库中，就可以轻松地在推荐物品的过程中使用 Embedding 去计算相似性等重要的特征了。<br><img src="../Pics/%E8%AF%8D%E5%90%91%E9%87%8F%E4%BB%8E%20Word2vec.webp" alt="词向量"></p>
</li>
</ul>
<h3 id="Embedding方法：item2vec"><a href="#Embedding方法：item2vec" class="headerlink" title="Embedding方法：item2vec"></a>Embedding方法：item2vec</h3><p>既然 Word2vec 可以对词“序列”中的词进行 Embedding，那么对于用户购买“序列”中的一个商品，用户观看“序列”中的一个电影，也应该存在相应的 Embedding 方法。<br>Item2vec 可以利用物品的 Embedding 直接求得它们的相似性，或者作为重要的特征输入推荐模型进行训练，这些都有助于提升推荐系统的效果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def trainItem2vec(spark, samples, embLength, embOutputPath, saveToRedis, redisKeyPrefix):</span><br><span class="line">    word2vec = Word2Vec().setVectorSize(embLength).setWindowSize(5).setNumIterations(10)</span><br><span class="line">    model = word2vec.fit(samples)</span><br><span class="line">    synonyms = model.findSynonyms(<span class="string">&quot;158&quot;</span>, 20)</span><br><span class="line">    <span class="keyword">for</span> synonym, cosineSimilarity <span class="keyword">in</span> synonyms:</span><br><span class="line">        <span class="built_in">print</span>(synonym, cosineSimilarity)</span><br><span class="line">    embOutputDir = <span class="string">&#x27;/&#x27;</span>.<span class="built_in">join</span>(embOutputPath.<span class="built_in">split</span>(<span class="string">&#x27;/&#x27;</span>)[:-1])</span><br><span class="line">    <span class="keyword">if</span> not os.path.exists(embOutputDir):</span><br><span class="line">        os.makedirs(embOutputDir)</span><br><span class="line">    with open(embOutputPath, <span class="string">&#x27;w&#x27;</span>) as f:</span><br><span class="line">        <span class="keyword">for</span> movie_id <span class="keyword">in</span> model.getVectors():</span><br><span class="line">            vectors = <span class="string">&quot; &quot;</span>.<span class="built_in">join</span>([str(emb) <span class="keyword">for</span> emb <span class="keyword">in</span> model.getVectors()[movie_id]])</span><br><span class="line">            f.write(movie_id + <span class="string">&quot;:&quot;</span> + vectors + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    embeddingLSH(spark, model.getVectors())</span><br><span class="line">    <span class="built_in">return</span> model</span><br></pre></td></tr></table></figure>

<h2 id="Embedding-优势"><a href="#Embedding-优势" class="headerlink" title="Embedding 优势"></a>Embedding 优势</h2><p>Embedding 是处理稀疏特征的利器。 几乎所有深度学习推荐模型都会由 Embedding 层负责将稀疏高维特征向量转换成稠密低维特征向量。<br>Embedding 可以融合大量有价值信息，本身就是极其重要的特征向量 。 相比由原始信息直接处理得来的特征向量，Embedding 的表达能力更强，特别是 Graph Embedding 技术被提出后，Embedding 几乎可以引入任何信息进行编码，使其本身就包含大量有价值的信息，所以通过预训练得到的 Embedding 向量本身就是极其重要的特征向量。</p>
<h2 id="实时特征加工"><a href="#实时特征加工" class="headerlink" title="实时特征加工"></a>实时特征加工</h2><p>实时特征加工的源头多为埋点数据落的 Kafka 数据（实时流-多为json格式），通过 flink 任务加工成用户所有的 kv 格式数据，在 ctr 场景中，key多为用户pin，value多为用户特征值，举例value可能为 0和1 在性别场景下</p>
<h2 id="训练框架场景"><a href="#训练框架场景" class="headerlink" title="训练框架场景"></a>训练框架场景</h2><p>用户加工好实时特征，多为keyvalue的形式存储在数据库中，如果想通过深度学习模型进一步训练，需要将特征进行 Embedding 特征工程。Embedding特征工程后，通过 Embedding 层、attention层、MLP层等网络架构，进行模型训练，从而得到模型文件进行模型服务和特征服务</p>
<h2 id="实时特征存储"><a href="#实时特征存储" class="headerlink" title="实时特征存储"></a>实时特征存储</h2><p>特征服务，包括召回服务等，数据往往存储在 redis 中，通过快速的点查支持线上业务</p>
<h2 id="实时特征服务"><a href="#实时特征服务" class="headerlink" title="实时特征服务"></a>实时特征服务</h2><p>线上服务，一般包含模型服务和特征服务</p>
<h2 id="其他QA"><a href="#其他QA" class="headerlink" title="其他QA"></a>其他QA</h2><ul>
<li>Q：为什么深度学习的结构特点不利于稀疏特征向量的处理呢？</li>
<li>A：是因为深度学习通过反向传播算法来更新参数的值，损失函数对参数w的梯度与其对应的a有关，对于稀疏向量而言，会有大量的a为0，根据链式法则，那么相应的权重w的更新梯度也会为0，从而出现梯度消失的问题。<br></li>
<li>Q：常用的相似度度量方法？</li>
<li>A：余弦距离可以体现数值的相对差异，欧式距离体现数值的绝对差异；例如，衡量用户点击次数的相似度，欧氏距离更好，衡量用户对各类电影的喜好的相似度，用余弦距离更好；线上快速召回一般有用ANN，比如LSH算法进行近似召回。<br></li>
<li>Q：物品embedding和用户embedding如何一起训练，让他们在同一个空间里呢，我理解这样才可以进行物品和用户的相似度计算。</li>
<li>A：方法一是item embedding生成好后，再利用item embedding生成user embedding。方法二是使用矩阵分解这类方法生成item和user embedding。<br>
Embedding 可以是实时特征嘛？如何实时读取 Embedding 特征？向量数据库的原理？Facebook开源的faiss？</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://shuo-shuo.site/2024/03/03/%E6%9C%89%E5%85%B3Sora%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sure Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sure's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/03/%E6%9C%89%E5%85%B3Sora%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/" class="post-title-link" itemprop="url">有关Sora的一点思考</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-03-03 22:11:16 / Modified: 22:11:47" itemprop="dateCreated datePublished" datetime="2024-03-03T22:11:16+08:00">2024-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>877</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>openAI 近期发布的文生视频、图生视频模型，可以以简单的 Prompt 生成逼真的、无ps痕迹的视频，也是如今 AI 界的一大变革。</p>
<h2 id="历史演进"><a href="#历史演进" class="headerlink" title="历史演进"></a>历史演进</h2><p>文生图的技术，最早可以追溯到 Stable Diffusion模型， 其中大家耳熟能详的 CLIP 模型（多模态模型）主要做的事情是，zero-shot prediction，通过文本特征和图片特征做相关性匹配，进而通过 prompt 对图片进行分类。而 Stable Diffusion 用到的技术主要有两个，一是 Transformer，把 Transformer 架构应用于 CV 领域；二是 图像文本描述的增强，通过文本描述来提升模型的生成能力；文生视频的技术主要在于对时空语义建模，也是使用的 Transformer 架构，首先需要对视频的隐空间表示 patch 化，其次需要利用 Transformer 架构对空间维度和时间维度的语义进行建模；</p>
<h2 id="Sora-思考"><a href="#Sora-思考" class="headerlink" title="Sora 思考"></a>Sora 思考</h2><p>Sora 简介：text conditional diffusion models: 基于不同时间长度、像素大小、尺寸，使用 transformer 架构 —&gt; 生成分钟级的高保真模型。</p>
<h3 id="几大特点："><a href="#几大特点：" class="headerlink" title="几大特点："></a>几大特点：</h3><ol>
<li>视频训练模型新范式：<br>图像数据转Patches，先压缩，浅空间里大量训练，时间、空间提取出来<br>通过扩散模型解压到像素空间<br>resolutions，aspect ratios（不同时间长度、不同像素、不同尺寸）<br>语言理解程度，训练模型做标注，通过 GPT 对短的语言模型进行加长，视频标注和文本对齐。</li>
<li>通过图片和视频，进行二次加工，通过图片生成动画。</li>
<li>扩帧已有视频</li>
<li>视频改造（video editing）</li>
</ol>
<h3 id="核心延展："><a href="#核心延展：" class="headerlink" title="核心延展："></a>核心延展：</h3><ul>
<li>3D 场景一致性（3D一致性）</li>
<li>前后关联性（long-range coherence and object permanence）</li>
<li>模拟虚拟世界能力</li>
</ul>
<h3 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h3><ol>
<li>sora 需要巨大的算力才能支撑起一分钟的时间窗口，看起来也像是大力出奇迹的作品</li>
<li>多模态模型，预测是未来趋势，但是从 CLIP 模型开始，小公司就没有那么大的算力来陪跑了，文生视频模型看起来也是算力垄断公司的作品</li>
<li>Text Encoder，扩散能力、自动标注 是否也将长期成为大模型领域的重点？</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://shuo-shuo.site/2023/10/19/Checkpoint%E5%8E%9F%E7%90%86%E5%92%8C%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sure Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sure's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/19/Checkpoint%E5%8E%9F%E7%90%86%E5%92%8C%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Checkpoint原理和机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-19 22:00:39" itemprop="dateCreated datePublished" datetime="2023-10-19T22:00:39+08:00">2023-10-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-06 10:21:22" itemprop="dateModified" datetime="2024-01-06T10:21:22+08:00">2024-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Flink-模式下的-Checkpoint"><a href="#Flink-模式下的-Checkpoint" class="headerlink" title="Flink 模式下的 Checkpoint"></a>Flink 模式下的 Checkpoint</h1><p>Flink 的检查点机制，在流处理中，主要为了实现数据一致性和容错恢复，Checkpoint能够根据配置周期性地基于 Stream 中各个 Operator/task的状态来生成快照，从而将这些状态数据定期持久化存储下来，当Flink程序一旦意外崩溃时，系统可以在发生故障时回滚，重新运行程序时可以有选择地从这些快照进行恢复，从而修正因为故障带来的程序数据异常。</p>
<p>另一个重要的概念：barrier，barrier 将数据流中的记录隔离成一系列的记录集合；barrier被注入到并行流的数据源，注入快照n (称为Sn)的barriers 是数据源中的一个位置，在 kafka的某个分区的最后一条记录的offset。这个位置Sn后续会汇报给JM的checkpoint 协调器。barrier随着流向下游流动，当中间的operator从他所有的输入流中收到checkpoint n 的barrier时，该operator会将barrier发送给他的下游operator。</p>
<p>JobManager -&gt; Source（发送 barrier）-&gt; 初始化 Checkpoint<br>Source -&gt; 接收 Barrier -&gt; Checkpoint 自己的 state -&gt; 下游发送 Barrier</p>
<p>下游收到 Barrier 后，进行 Barrier Alignment 处理；Task 开始同步阶段的 Snapshot；Task 做完 Checkpoint 之后，再上报 JobManager</p>
<p>默认checkpoint功能是 disabled 的，想要使用的时候需要先启用。checkpoint开启之后，默认的checkPointMode是Exactly-once。<br>checkPointMode有两种：</p>
<ul>
<li>Exactly-once: 数据处理且只被处理一次</li>
<li>At-least-once：数据至少被处理一次</li>
</ul>
<h1 id="算法模型下的-Checkpoint"><a href="#算法模型下的-Checkpoint" class="headerlink" title="算法模型下的 Checkpoint"></a>算法模型下的 Checkpoint</h1><p>在模型训练过程中，可以添加检查点(CheckPoint)用于保存模型的参数，以便进行推理及中断后再训练使用。</p>
<p>使用场景如下：</p>
<ul>
<li>训练后推理场景</li>
<li>模型训练完毕后保存模型的参数，用于推理或预测操作</li>
<li>训练过程中，通过实时验证精度，把精度最高的模型参数保存下来，用于预测操作。</li>
</ul>
<p>再训练场景：</p>
<ul>
<li>进行长时间训练任务时，保存训练过程中的CheckPoint文件，防止任务异常退出后从初始状态开始训练。</li>
</ul>
<p>Fine-tuning（微调）场景：<br>训练一个模型并保存参数，基于该模型，面向第二个类似任务进行模型训练。</p>
<p>MindSpore的CheckPoint文件是一个二进制文件，存储了所有训练参数的值。采用了Google的Protocol Buffers机制，与开发语言、平台无关，具有良好的可扩展性。 CheckPoint的protocol格式定义在mindspore/ccsrc/utils/checkpoint.proto中。</p>
<p>以下通过一个示例来介绍MindSpore保存和加载的功能，网络选取ResNet-50，数据集为MNIST。</p>
<p>在模型训练的过程中，使用 callback 机制传入回调函数ModelCheckpoint 对象，可以保存模型参数，生成 CheckPoint 文件。 通过CheckpointConfig对象可以设置CheckPoint的保存策略。 保存的参数分为网络参数和优化器参数。</p>
<h1 id="数据湖版本管理"><a href="#数据湖版本管理" class="headerlink" title="数据湖版本管理"></a>数据湖版本管理</h1><p>数据湖是一种存储系统，可以存储任意规模的结构化和非结构化数据。</p>
<p>Delta Lake：是由 Databricks 推出的一种基于 Apache Spark 和 Apache Parquet 的开源数据湖技术。Delta Lake 提供了 ACID 事务、数据版本控制、数据一致性、数据可靠性、数据质量等功能，使数据湖更加健壮和易于管理。Delta Lake 还支持 SQL 查询、Scala/Python/Java API、Spark Streaming、Delta Lake Connectors 等功能。</p>
<p>Apache Hudi：是由 Uber 提出的一种基于 Apache Hadoop 和 Apache Spark 的开源数据湖技术。Hudi 提供了支持增量更新和删除、支持数据版本控制和数据访问控制、支持数据一致性和数据质量控制等功能。Hudi 还支持多种存储格式和存储介质，包括 Parquet、ORC、HDFS、S3、等。</p>
<p>Apache Iceberg：是由 Netflix 提出的一种基于 Apache Hadoop 和 Apache Spark 的开源数据湖技术。Iceberg 提供了快速的数据写入和查询操作、数据版本控制、数据质量控制等功能。Iceberg 还支持多种存储介质和存储格式，包括 Parquet、ORC、Avro、HDFS、S3、等。同时，</p>
<p>Iceberg 支持 SQL 查询、Java API、Spark API 等多种数据访问方式。</p>
<p>优势：</p>
<ul>
<li>Iceberg 底层依赖的存储是像 HDFS 或 S3 这样的廉价存储</li>
<li>Iceberg 是支持 parquet、orc、Avro 这样的列式存储。有列式存储的支持，就可以对 OLAP 分析进行基本的优化，在中间层直接进行计算。例如谓词下推最基本的 OLAP 优化策略，基于 Iceberg snapshot 的 Streaming reader 功能，可以把离线任务天级别到小时级别的延迟大大的降低，改造成一个近实时的数据湖分析系统。</li>
</ul>
<p>劣势：</p>
<ul>
<li>对于大表 JOIN 不够友好</li>
<li>Flink 不支持创建带有隐藏分区的 Iceberg 表</li>
<li>Flink 不支持带有 WaterMark 的 Iceberg 表</li>
<li>Iceberg 只支持一种表存储模式，就是有 metadata file、manifest file 和 data file 组成存储结构，查询时首先查找 Metadata 元数据进而过滤找到对应的 SnapShot 对应的 manifest files ,再找到对应的数据文件。Hudi 支持两种表存储模式：Copy On Write（写时合并） 和 Merge On Read（读时合并），查询时直接读取对应的快照数据。</li>
<li>对于处理小文件合并时，Iceberg 只支持 API 方式手动处理合并小文件，Hudi 对于小文件合并处理可以根据配置自动的执行</li>
<li>Spark 与 Iceberg 和 Hudi 整合时，Iceberg 对 SparkSQL 的支持目前来看更好。Spark 与 Hudi 整合更多的是 Spark DataFrame API 操作</li>
<li>关于 Schema 方面，Iceberg Schema 与计算引擎是解耦的，不依赖任何的计算引擎，而 Hudi 的 Schema 依赖于计算引擎 Schema。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://shuo-shuo.site/2023/09/18/%E6%B5%81%E5%A4%84%E7%90%86%E6%89%B9%E5%A4%84%E7%90%86%E5%92%8CKappa%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sure Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sure's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/18/%E6%B5%81%E5%A4%84%E7%90%86%E6%89%B9%E5%A4%84%E7%90%86%E5%92%8CKappa%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">流处理批处理和Kappa架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-09-18 23:35:00 / Modified: 23:49:17" itemprop="dateCreated datePublished" datetime="2023-09-18T23:35:00+08:00">2023-09-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%B5%81%E6%89%B9%E4%B8%80%E4%BD%93/" itemprop="url" rel="index"><span itemprop="name">流批一体</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>242</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="批处理适合的领域"><a href="#批处理适合的领域" class="headerlink" title="批处理适合的领域"></a>批处理适合的领域</h1><ul>
<li>数据探索、机器学习实验，需要使用批处理来反复验证不同的算法</li>
<li>大规模并行处理</li>
<li>数据来源通常为 Hive、HDFS</li>
<li>数据时效性要求不高，可以支持 T+1 数据延迟</li>
</ul>
<h1 id="流批一体-Kappa-架构适合的领域"><a href="#流批一体-Kappa-架构适合的领域" class="headerlink" title="流批一体 Kappa 架构适合的领域"></a>流批一体 Kappa 架构适合的领域</h1><ul>
<li>逻辑固定的数据预处理流程（统计一个时间段内商品的曝光和购买次数、某些关键词的搜索次数等）</li>
<li>离线/实时 各落一份数据</li>
</ul>
<p>栈，后进先出（Last in First Out）</p>
<ul>
<li>顺序结构，使用数组实现</li>
<li>链式结构，使用链表实现</li>
</ul>
<p>队列，先进先出（First in First Out）</p>
<ul>
<li>顺序结构，使用数组实现</li>
<li>链式结构，使用链表实现</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://shuo-shuo.site/2023/09/10/%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E6%B9%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sure Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sure's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/10/%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E6%B9%96/" class="post-title-link" itemprop="url">初识数据湖</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-09-10 22:46:50" itemprop="dateCreated datePublished" datetime="2023-09-10T22:46:50+08:00">2023-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-11 23:19:21" itemprop="dateModified" datetime="2023-09-11T23:19:21+08:00">2023-09-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>733</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="大数据的现状"><a href="#大数据的现状" class="headerlink" title="大数据的现状"></a>大数据的现状</h1><p>近年来，湖仓一体架构在大数据领域很受青睐，顾名思义，湖仓一体式将数据湖和数据仓库集成起来的架构，以数据湖为中心，周边集成了云上数据服务，包括数据仓库、机器学习、大数据处理、关系型数据库、非关系型数据库、搜索服务等。其中入湖入仓，湖仓打通、数据出湖、数据处理和数据消费，将各种云上数据服务集成到一起。</p>
<h1 id="数据湖简介"><a href="#数据湖简介" class="headerlink" title="数据湖简介"></a>数据湖简介</h1><p>数据湖中数据包括 结构化数据（关系型数据库）；半结构化数据（CSV、Json、XML等）；非结构化数据/二进制数据（图片、视频）；</p>
<h2 id="数据湖的特性："><a href="#数据湖的特性：" class="headerlink" title="数据湖的特性："></a>数据湖的特性：</h2><ul>
<li>MOR（merge on read）：写入在分析时，类似 github 的 push</li>
<li>Update，只更新单列</li>
<li>更快查询结果、较低存储成本</li>
<li>可用于算法领域，机器学习、预测分析等</li>
</ul>
<h2 id="技术视角分析数据湖："><a href="#技术视角分析数据湖：" class="headerlink" title="技术视角分析数据湖："></a>技术视角分析数据湖：</h2><p>数据湖具备数据管理、数据溯源、流批一体的数据入湖架构，通常数据湖都会支持SQL和可编程的 Flink/Spark 数据处理能力，通常支持有向无环图的工作流模式。<br>最好可以提供一个标准的访问接口，类似于 JDBC 接口可以直接访问数据；</p>
<ul>
<li>风控、推荐、预警（搜索下拉场景，来一条数据处理一条）</li>
<li>日活、留存、转化（CTR场景下，数据探索类应用）</li>
<li>图片、视频存储（多模态场景下，存储多模态数据）</li>
</ul>
<h2 id="阿里云案例-开源生态构建数据湖"><a href="#阿里云案例-开源生态构建数据湖" class="headerlink" title="阿里云案例 - 开源生态构建数据湖"></a>阿里云案例 - 开源生态构建数据湖</h2><ul>
<li>提供数据湖元数据管理、数据湖加速等服务</li>
<li>客户价值1： 通过分层存储，引入多存储类型解决客户温/冷数据长期存储成本优化，让用户资源扩容更加灵活</li>
<li>客户价值2: 计算与存储弹性扩展能力降低管理运维难度，存储与计算的解耦合，让升级更具灵活性</li>
</ul>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul>
<li><p>典型的数据湖架构：<br>分布式对象存储+多模态计算引擎+数据管理</p>
</li>
<li><p>典型大数据仓库存储架构：<br>FDM（原始数据） + GDM（整合和拉宽数据） + ADM（轻量汇总数据） + APP（业务定制数据） + DEV层（临时数据）</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://shuo-shuo.site/2023/08/31/pb%E3%80%81parquet%E5%92%8CTFRecord%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sure Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sure's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/31/pb%E3%80%81parquet%E5%92%8CTFRecord%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AF%B9%E6%AF%94/" class="post-title-link" itemprop="url">pb和parquet及TFRecord格式介绍与对比</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-31 21:48:40" itemprop="dateCreated datePublished" datetime="2023-08-31T21:48:40+08:00">2023-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-03-18 22:49:19" itemprop="dateModified" datetime="2024-03-18T22:49:19+08:00">2024-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>大规模数据分析、异构数据源场景、数据、模型等IO要求高场景需要 parquet 数据格式，同样 pb 等序列化结构数据，在数据传输、存储中占用资源较少，因此 PB 文件也广泛的应用于算法之中。</p>
<h1 id="pb（Protocol-Buffers）"><a href="#pb（Protocol-Buffers）" class="headerlink" title="pb（Protocol Buffers）"></a>pb（Protocol Buffers）</h1><p>序列化结构化数据（二进制）适用于数据量大、数据传输效率高的场景</p>
<ul>
<li>序列化后，数据流小，占用网络单款少</li>
<li>序列化和反序列化的性能，占用CPU资源少</li>
<li>数据本身不可读，需要反序列化后可读数据</li>
<li>解析速度快（比 XML、JSON 快20-100倍）</li>
<li>适配算法场景</li>
</ul>
<h1 id="定义pb文件规范"><a href="#定义pb文件规范" class="headerlink" title="定义pb文件规范"></a>定义pb文件规范</h1><ul>
<li>proto文件<figure class="highlight bash"><figcaption><span>创建proto文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment"># proto3语法</span></span><br><span class="line"><span class="comment"># 用户服务请求</span></span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">  string query = 1;</span><br><span class="line">  int32 page_number = 2;</span><br><span class="line">  int32 result_per_page = 3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 服务请求返回</span></span><br><span class="line">message MyRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">  int32 age = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>文件中定义message类型的数据格式<figure class="highlight bash"><figcaption><span>message类型数据格式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一级视图，可作为业务</span></span><br><span class="line"> message MyRequest &#123;</span><br><span class="line">    string name = 1;</span><br><span class="line">    int32 gender = 2;</span><br><span class="line">    optional bytes predict_gender = 3;  <span class="comment"># 算法场景bytes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二级视图，可作为特征</span></span><br><span class="line"> message gender &#123;</span><br><span class="line">    string male = 1;</span><br><span class="line">    string female = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数据流-Data2protobuf-Function"><a href="#数据流-Data2protobuf-Function" class="headerlink" title="数据流-Data2protobuf Function"></a>数据流-Data2protobuf Function</h2><ul>
<li>pb 类名（pb 所在完整类名，存储于自定义资产中）</li>
<li>数据类型支持<ul>
<li>byteArray（byte数组转pb）</li>
<li>JSON（json字符串转pb）</li>
</ul>
</li>
</ul>
<h2 id="动态PB"><a href="#动态PB" class="headerlink" title="动态PB"></a>动态PB</h2><p>hive/topic 增加字段，spark/flink 调用 SDK 的入参增加新字段 &lt;dataId, value&gt;, SDK 读取 DUCC 配置感知新增字段，SDK 判断入参增加字段，进行数据更新时，动态增加对字段的序列化/反序列化处理逻辑。</p>
<ul>
<li>键-值 序列化</li>
</ul>
<h1 id="Parquet"><a href="#Parquet" class="headerlink" title="Parquet"></a>Parquet</h1><p>parquet 采用类似 PB 协议来描述存储结果schema。列存储、大数据存储格式、Hadoop 生态圈</p>
<ul>
<li>适用于 OLAP 场景</li>
<li>适用于 模型训练 场景</li>
<li>优势：更高压缩比、更小 IO 操作，适配多语言和组件</li>
<li>行组 + 列块 + 页</li>
</ul>
<p>Parquet 通常和 挂盘功能一并使用，挂载（mounting）是指由操作系统使一个存储设备（诸如硬盘、CD-ROM或共享资源）上的计算机文件和目录可供用户通过计算机的文件系统访问的一个过程。 一般来说，当计算机关机时，每个已挂载存储都将经历一次卸载，以确保所有排队的数据被写入，并保证介质上文件系统结构的完整性。 访问这个目录来访问存储设备。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">message AddressBook &#123;</span><br><span class="line"> required string owner;</span><br><span class="line"> repeated string ownerPhoneNumbers;</span><br><span class="line"> repeated group contacts &#123;</span><br><span class="line">   required string name;</span><br><span class="line">   optional string phoneNumber; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TF-Record"><a href="#TF-Record" class="headerlink" title="TF Record"></a>TF Record</h1><p>Tensorflow 自带的数据格式，将数据存储为二进制文件（二进制存储具有占用空间少，拷贝和读取（from disk）更加高效的特点），而且不需要单独的标签文件了，其本质是一行行字节字符串构成的样本数据。</p>
<ul>
<li>训练方式：1、内存； 2、使用 queue/tf.data</li>
<li>优势<ul>
<li>1、支持延迟加载</li>
<li>2、原生tensorflow支持</li>
<li>3、protocol buffer 数据标准</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><figcaption><span>生成 TFRecord文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line">writer = tf.python_io.TFRecordWriter(<span class="string">&quot;./1.tfrecords&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(200):  <span class="comment"># 假设我们在一个文件中保存200个Example</span></span><br><span class="line">    example = tf.train.Example(...)</span><br><span class="line">    writer.write(example.SerializeToString())</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><figcaption><span>读取TFRecord文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def read_demo(filepath):</span><br><span class="line">		<span class="comment"># 定义schema</span></span><br><span class="line">    schema = &#123;</span><br><span class="line">        <span class="string">&#x27;user_id&#x27;</span>: tf.FixedLenFeature([], tf.int64),</span><br><span class="line">        <span class="string">&#x27;city_id&#x27;</span>: tf.FixedLenFeature([], tf.int64),</span><br><span class="line">        <span class="string">&#x27;app_type&#x27;</span>: tf.FixedLenFeature([], tf.int64),</span><br><span class="line">        <span class="string">&#x27;viewed_pois&#x27;</span>: tf.VarLenFeature(tf.int64),</span><br><span class="line">        <span class="string">&#x27;avg_paid&#x27;</span>: tf.FixedLenFeature([], tf.float32, default_value=0.0),</span><br><span class="line">        <span class="string">&#x27;comment&#x27;</span>: tf.FixedLenFeature([], tf.string, default_value=<span class="string">&#x27;&#x27;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="comment"># 使用相关api，按照schema解析dataset中的样本</span></span><br><span class="line">    def _parse_function(example_proto):</span><br><span class="line">        <span class="built_in">return</span> tf.parse_single_example(example_proto, schema)</span><br><span class="line">		</span><br><span class="line">    <span class="comment"># 读取TFRecord文件来创建dataset</span></span><br><span class="line">    dataset = tf.data.TFRecordDataset(filepath)</span><br><span class="line">    <span class="comment">#按照schema解析dataset中的每个样本</span></span><br><span class="line">    parsed_dataset = dataset.map(_parse_function)</span><br><span class="line">    <span class="comment">#创建Iterator并迭代Iterator即可访问dataset中的样本</span></span><br><span class="line">    next = parsed_dataset.make_one_shot_iterator().get_next()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这里直接利用session，打印dataset中的样本</span></span><br><span class="line">    with tf.Session() as sess:</span><br><span class="line">        <span class="keyword">while</span> True:</span><br><span class="line">            try:</span><br><span class="line">                <span class="built_in">print</span> sess.run(next)</span><br><span class="line">            except:</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&quot;out of data&quot;</span></span><br><span class="line">                <span class="built_in">break</span></span><br></pre></td></tr></table></figure>

<h1 id="Json-和-XML-和-ORC"><a href="#Json-和-XML-和-ORC" class="headerlink" title="Json 和 XML 和 ORC"></a>Json 和 XML 和 ORC</h1><p>Json，数据支持好，支持所有编程语言，但不适用于大数据量的传输场景</p>
<p>XML，用于序列化和封装数据。采用键值对的方式，可读性高，压缩数据空间</p>
<p>ORC，列存</p>
<ul>
<li>ORC 嵌套和损耗较大</li>
<li>支持 update 和 ACID</li>
</ul>
<p>Avro，基于行的存储格式，被广泛用作序列化过程。</p>
<ul>
<li>可拆分的</li>
<li>可压缩的</li>
<li>以 Json 定义的 Avro 模式，便于阅读和解析</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Sure Zheng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/Categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/shuo-zh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shuo-zh" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="gmail:zhengdashuo007@gmail.com" title="E-Mail → gmail:zhengdashuo007@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/san_zheng" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;san_zheng" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="/shuo-zh.github.io" title="shuo-zh.github.io">BLOG</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sure Zheng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
